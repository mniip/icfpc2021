{-# LANGUAGE BangPatterns, DerivingStrategies, PatternSynonyms, ViewPatterns #-}
module ICFPC.Vector where

import Data.Bits

-- 2D vector: V2 x y
data V2 = V2 {-# UNPACK #-} !Int {-# UNPACK #-} !Int
  deriving stock (Eq, Ord, Show)

{-# INLINE packV2 #-}
packV2 :: (Int, Int) -> V2
packV2 (x, y) = V2 x y

{-# INLINE unpackV2 #-}
unpackV2 :: V2 -> (Int, Int)
unpackV2 (V2 x y) = (x, y)

{-# INLINE (.+.) #-}
(.+.) :: V2 -> V2 -> V2
V2 x1 y1 .+. V2 x2 y2 = V2 (x1 + x2) (y1 + y2)
infixl 6 .+.

{-# INLINE (.-.) #-}
(.-.) :: V2 -> V2 -> V2
V2 x1 y1 .-. V2 x2 y2 = V2 (x1 - x2) (y1 - y2)
infixl 6 .-.

{-# INLINE negateV2 #-}
negateV2 :: V2 -> V2
negateV2 (V2 x y) = V2 (-x) (-y)

{-# INLINE (.*.) #-}
(.*.) :: Int -> V2 -> V2
k .*. V2 x y = V2 (k * x) (k * y)
infixl 7 .*.

{-# INLINE dot #-}
-- inner/dot product
dot :: V2 -> V2 -> Int
V2 x1 y1 `dot` V2 x2 y2 = x1 * x2 + y1 * y2
infixl 7 `dot`

{-# INLINE ccw #-}
-- rotate counter clockwise
ccw :: V2 -> V2
ccw (V2 x y) = V2 (-y) x

{-# INLINE signedArea #-}
-- signed area of a parallelogram subtended by two vectors
-- signedArea (V2 1 0) (V2 0 1) = 1
signedArea :: V2 -> V2 -> Int
signedArea u v = ccw u `dot` v

-- 2D line segment: S2 x1 y1 x2 y2
data S2 = S2 {-# UNPACK #-} !Int {-# UNPACK #-} !Int {-# UNPACK #-} !Int {-# UNPACK #-} !Int
  deriving stock (Eq, Ord, Show)

pattern S2V2 :: V2 -> V2 -> S2
pattern S2V2{source, target} <- S2 x1 (V2 x1 -> source) x2 (V2 x2 -> target)
  where S2V2 (V2 x1 y1) (V2 x2 y2) = S2 x1 y1 x2 y2

-- what is "compare (x * y) 0" except we don't overflow
productSign :: Int -> Int -> Ordering
productSign x y = case (compare x 0, compare y 0) of
  (EQ, _) -> EQ
  (_, EQ) -> EQ
  (LT, LT) -> GT
  (GT, GT) -> GT
  (LT, GT) -> LT
  (GT, LT) -> LT

-- whether two vectors lie on different sides of the line generated by given segment
separates :: S2 -> V2 -> V2 -> Bool
separates (S2V2 a b) p q = productSign (signedArea ba (p .-. a)) (signedArea ba (q .-. a)) /= GT
  where !ba = b .-. a

separatesStrictly :: S2 -> V2 -> V2 -> Bool
separatesStrictly (S2V2 a b) p q = productSign (signedArea ba (p .-. a)) (signedArea ba (q .-. a)) == LT
  where !ba = b .-. a

-- any sort of touching allowed
segmentsIntersect :: S2 -> S2 -> Bool
segmentsIntersect ab@(S2V2 a b) pq@(S2V2 p q) = separates ab p q && separates pq a b

-- segments have a proper intersection (at nonzero angle) among their interiors (no ends)
segmentsIntersectStrictly :: S2 -> S2 -> Bool
segmentsIntersectStrictly ab@(S2V2 a b) pq@(S2V2 p q) = separatesStrictly ab p q && separatesStrictly pq a b

type Dist = Int

{-# INLINE dist #-}
dist :: V2 -> V2 -> Dist
dist u v = uv `dot` uv
  where !uv = v .-. u

{-# INLINE distSeg #-}
distSeg :: S2 -> Dist
distSeg (S2V2 u v) = dist u v
